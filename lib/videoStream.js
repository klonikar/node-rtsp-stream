// Generated by CoffeeScript 1.8.0
(function() {
  var Mpeg1Muxer, STREAM_MAGIC_BYTES, VideoStream, events, util, ws;

  ws = require('ws');
  util = require('util');

  events = require('events');

  Mpeg1Muxer = require('./mpeg1muxer');

  STREAM_MAGIC_BYTES = "jsmp";

  VideoStream = function(options) {
    this.name = options.name;
    this.streamUrl = options.streamUrl;
    this.width = options.width;
    this.height = options.height;
    this.wsPort = options.wsPort;
    this.sslCredentials = options.sslCredentials;
    this.transport = options.transport || "tcp";
    this.inputStreamStarted = false;
    this.stream = void 0;
    this.startMpeg1Stream();
    this.pipeStreamToSocketServer();
    return this;
  };

  util.inherits(VideoStream, events.EventEmitter);

  VideoStream.prototype.startMpeg1Stream = function() {
    var gettingInputData, gettingOutputData, inputData, outputData, self;
    this.mpeg1Muxer = new Mpeg1Muxer({
      url: this.streamUrl,
	  width: this.width,
	  height: this.height,
    transport: this.transport
    });
    self = this;
    if (this.inputStreamStarted) {
      return;
    }
    this.mpeg1Muxer.on('mpeg1data', function(data) {
      return self.emit('camdata', data);
    });
    gettingInputData = false;
    inputData = [];
    gettingOutputData = false;
    outputData = [];
    this.mpeg1Muxer.on('ffmpegError', function(data) {
      var size;
      data = data.toString();
      if (data.indexOf('Input #') !== -1) {
        gettingInputData = true;
      }
      if (data.indexOf('Output #') !== -1) {
        gettingInputData = false;
        gettingOutputData = true;
      }
      if (data.indexOf('frame') === 0) {
        gettingOutputData = false;
      }
      if (gettingInputData) {
        inputData.push(data.toString());
        size = data.match(/\d+x\d+/);
        if (size != null) {
          size = size[0].split('x');
          if (self.width == null) {
            self.width = parseInt(size[0], 10);
          }
          if (self.height == null) {
            return self.height = parseInt(size[1], 10);
          }
        }
      }
    });
    //this.mpeg1Muxer.on('ffmpegError', function(data) {
      //return global.process.stderr.write(data);
    //});
    this.mpeg1Muxer.on('ffmpegExit', function(data) {
      console.log("ffmpeg process exited with code: ", data.code, ", signal: ", data.signal, ", restarting ffmpeg...");
      return setTimeout(function() {
          self.startMpeg1Stream();
      }, 5000);
    });
    return this;
  };

  VideoStream.prototype.pipeStreamToSocketServer = function() {
    var self = this;
    if(this.sslCredentials && this.sslCredentials.keyFile && this.sslCredentials.certificateFile) {
        const express = require('express');
        const https = require('https');
        const fs = require('fs');
        const app = express();

        var privateKey  = fs.readFileSync(this.sslCredentials.keyFile, 'utf8');
        var certificate = fs.readFileSync(this.sslCredentials.certificateFile);

        var credentials = {key: privateKey, cert: certificate};

        var httpsServer = https.createServer(credentials, app);
        httpsServer.listen(this.wsPort);
        this.wsServer = new ws.Server({
            server: httpsServer  // wss://<IPAddr>:port
        });
    }
    else {
        this.wsServer = new ws.Server({
          port: this.wsPort, host: null  // ws://<IPAddr>:port
        });
    }

    this.wsServer.on("connection", function(socket) {
      return self.onSocketConnect(socket);
    });
    this.wsServer.broadcast = function(data, opts) {
      var i, _results;
      _results = [];
      for (i in this.clients) {
        if (this.clients[i].readyState === 1) {
          _results.push(this.clients[i].send(data, opts));
        } else {
          _results.push(console.log("Error: Client (" + i + ") not connected."));
        }
      }
      return _results;
    };
    return this.on('camdata', function(data) {
      return self.wsServer.broadcast(data);
    });
  };

  VideoStream.prototype.onSocketConnect = function(socket) {
    var self, streamHeader;
    self = this;
    streamHeader = new Buffer(8);
    streamHeader.write(STREAM_MAGIC_BYTES);
    streamHeader.writeUInt16BE(self.width, 4);
    streamHeader.writeUInt16BE(self.height, 6);
    socket.send(streamHeader, {
      binary: true
    });
    console.log(("" + self.name + ": New WebSocket Connection (") + self.wsServer.clients.length + " total)");
    return socket.on("close", function(code, message) {
		/*if(self.wsServer.clients.length == 0){
			self.mpeg1Muxer.stream.kill();
			self.inputStreamStarted = false;
			self.wsServer.close();
		}*/
      return console.log(("" + self.name + ": Disconnected WebSocket (") + self.wsServer.clients.length + " total)");
    });
  };

  module.exports = VideoStream;

}).call(this);
